"use strict";(self.webpackChunksource_2_wiki=self.webpackChunksource_2_wiki||[]).push([[10794],{17496:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>a,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"type":"mdx","permalink":"/Entities/prop_static-cs2","source":"@site/src/pages/Entities/prop_static-cs2.mdx","description":"\x3c!---","frontMatter":{"hide_table_of_contents":true},"unlisted":false}');var r=s(74848),l=s(28453);const o={hide_table_of_contents:!0},t=void 0,c={},d=[];function h(e){const n={br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Point Entity"}),"\n",(0,r.jsxs)(s,{open:!0,children:[(0,r.jsx)("summary",{children:(0,r.jsx)("h2",{children:"Keyvalues"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model"})," (",(0,r.jsx)(n.code,{children:"model"}),") <",(0,r.jsx)(n.code,{children:"Resource"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tint Color"})," (",(0,r.jsx)(n.code,{children:"rendercolor"}),") <",(0,r.jsx)(n.code,{children:"Color255"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Material Group"})," (",(0,r.jsx)(n.code,{children:"skin"}),") <",(0,r.jsx)(n.code,{children:"MaterialGroup"}),">",(0,r.jsx)(n.br,{}),"\n","Some props have multiple matieral variations called Material Groups, here you can see what material groups are available for selection."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Collision Type"})," (",(0,r.jsx)(n.code,{children:"solid"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Not Solid"}),"\n",(0,r.jsx)(n.li,{children:"Use VPhysics"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Override Collision Property"})," (",(0,r.jsx)(n.code,{children:"collision_override"}),") <",(0,r.jsx)(n.code,{children:"CollisionProperty"}),">",(0,r.jsx)(n.br,{}),"\n","If a value is selected, it will be applied as the collision property to all of the phsyics shapes generated by this instance of the model, overriding any values specified in the model."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lighting Type"})," (",(0,r.jsx)(n.code,{children:"bakelighting"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Selects whether to use lightmapping or lightprobes for this mesh. Note: Selecting light probes will disable mesh merging/batching, creating extra draw calls. To merge lightprobed meshes, enable the Bake to World parameter."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Default"}),"\n",(0,r.jsx)(n.li,{children:"Lightmapped"}),"\n",(0,r.jsx)(n.li,{children:"Lightprobed"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Shadow Type"})," (",(0,r.jsx)(n.code,{children:"disableshadows"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Selects the type of shadows that should be cast from this prop_static."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Baked & Dynamic"}),"\n",(0,r.jsx)(n.li,{children:"Only Baked"}),"\n",(0,r.jsx)(n.li,{children:"Only Dynamic"}),"\n",(0,r.jsx)(n.li,{children:"None"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Emissive"})," (",(0,r.jsx)(n.code,{children:"emissive"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Allow this prop to emit lighting. Note that this only works on materials with Self Illum parameters, and is only visible in the GPU Path Tracing Preview and in the final lightmap bake."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Emissive Boost"})," (",(0,r.jsx)(n.code,{children:"emissive_lighting_boost"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Used to boost emissive lighting from a mesh. Note that boosting emissive on smaller meshes can create more lighting artifacts/noise."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lightmap Scale Bias"})," (",(0,r.jsx)(n.code,{children:"lightmapscalebias"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Used to scale the resolution of the lightmap for this mesh."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scale down by 8"}),"\n",(0,r.jsx)(n.li,{children:"Scale down by 4"}),"\n",(0,r.jsx)(n.li,{children:"Scale down by 2"}),"\n",(0,r.jsx)(n.li,{children:"Default (no scale)"}),"\n",(0,r.jsx)(n.li,{children:"Scale up by 2"}),"\n",(0,r.jsx)(n.li,{children:"Scale up by 4"}),"\n",(0,r.jsx)(n.li,{children:"Scale up by 8"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bake As Double-Sided"})," (",(0,r.jsx)(n.code,{children:"bakelightdoublesided"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Bakes the mesh as if it were double-sided geometry in the lightmapper. Useful on geometry with 'Render Backfaces' enabled via it's material (such as foliage). When the lightmapper sees many and/or large backfaces it will invalidate lightmap samples as an optimization, which can lead to lightmap errors/reduced quality in some circumstances."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Vis Occluder"})," (",(0,r.jsx)(n.code,{children:"visoccluder"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","If true this geometry is used as an occluder for precomputed visibility. As a rule this geometry should be as simplistic as possible"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Material Override"})," (",(0,r.jsx)(n.code,{children:"materialoverride"}),") <",(0,r.jsx)(n.code,{children:"Material"}),">",(0,r.jsx)(n.br,{}),"\n","This will override all materials on a selected mesh with a specific material"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Force Bake To World"})," (",(0,r.jsx)(n.code,{children:"baketoworld"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","If true mesh will be baked/merged into the world geometry of the map so that the model is not referenced at runtime. Use this if you want light probed static meshes to merge"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disable Mesh Merging"})," (",(0,r.jsx)(n.code,{children:"disablemerging"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","If true this will not be merged with other geometry during map compile (reduces rendering efficiency)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Render to Cubemaps"})," (",(0,r.jsx)(n.code,{children:"rendertocubemaps"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","If true, this geometry renders into baked cube maps"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explicit Cubemap"})," (",(0,r.jsx)(n.code,{children:"lightingorigin"}),") <",(0,r.jsx)(n.code,{children:"TargetDestination"}),">",(0,r.jsx)(n.br,{}),"\n","Used to manually assign a named env_cubemap, env_cubemap_box or env_combined_light_probe_volume to a mesh. Note: This forces the mesh into a slower rendering path and does not support the explicit assignment of lightprobes. Use with caution."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Render LOD"})," (",(0,r.jsx)(n.code,{children:"lodlevel"}),") <",(0,r.jsx)(n.code,{children:"LodLevel"}),">",(0,r.jsx)(n.br,{}),"\n","Auto for standard LOD behaviour, or select an explicit LOD to use. Note that LODs take up more room in the lightmap and do not merge, potentially making them less performant if used on many objects (Set to Auto)."]}),"\n"]}),"\n"]})]})]})}function a(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>t});var i=s(96540);const r={},l=i.createContext(r);function o(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);