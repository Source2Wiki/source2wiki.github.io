"use strict";(self.webpackChunksource_2_wiki=self.webpackChunksource_2_wiki||[]).push([[74150],{28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>d});var i=n(96540);const r={},l=i.createContext(r);function o(e){const s=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(l.Provider,{value:s},e.children)}},73129:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>d,default:()=>a,frontMatter:()=>o,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"type":"mdx","permalink":"/Entities/prop_static-dota2","source":"@site/src/pages/Entities/prop_static-dota2.mdx","description":"\x3c!---","frontMatter":{"hide_table_of_contents":true},"unlisted":false}');var r=n(74848),l=n(28453);const o={hide_table_of_contents:!0},d=void 0,c={},t=[];function h(e){const s={br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{Details:n}=s;return n||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"Point Entity"}),"\n",(0,r.jsxs)(n,{open:!0,children:[(0,r.jsx)("summary",{children:(0,r.jsx)("h2",{children:"Keyvalues"})}),(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Model"})," (",(0,r.jsx)(s.code,{children:"model"}),") <",(0,r.jsx)(s.code,{children:"Resource"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Tint Color"})," (",(0,r.jsx)(s.code,{children:"rendercolor"}),") <",(0,r.jsx)(s.code,{children:"Color255"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Material Group"})," (",(0,r.jsx)(s.code,{children:"skin"}),") <",(0,r.jsx)(s.code,{children:"MaterialGroup"}),">",(0,r.jsx)(s.br,{}),"\n","Some props have multiple matieral variations called Material Groups, here you can see what material groups are available for selection."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Collision Type"})," (",(0,r.jsx)(s.code,{children:"solid"}),") <",(0,r.jsx)(s.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Not Solid (",(0,r.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Use VPhysics (",(0,r.jsx)(s.code,{children:"6"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Override Collision Property"})," (",(0,r.jsx)(s.code,{children:"collision_override"}),") <",(0,r.jsx)(s.code,{children:"CollisionProperty"}),">",(0,r.jsx)(s.br,{}),"\n","If a value is selected, it will be applied as the collision property to all of the phsyics shapes generated by this instance of the model, overriding any values specified in the model."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Lighting Type"})," (",(0,r.jsx)(s.code,{children:"bakelighting"}),") <",(0,r.jsx)(s.code,{children:"Choices"}),">",(0,r.jsx)(s.br,{}),"\n","Selects whether to use lightmapping or lightprobes for this mesh. Note: Selecting light probes will disable mesh merging/batching, creating extra draw calls. To merge lightprobed meshes, enable the Bake to World parameter."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Default (",(0,r.jsx)(s.code,{children:"-1"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Lightmapped (",(0,r.jsx)(s.code,{children:"1"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Lightprobed (",(0,r.jsx)(s.code,{children:"0"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Shadow Type"})," (",(0,r.jsx)(s.code,{children:"disableshadows"}),") <",(0,r.jsx)(s.code,{children:"Choices"}),">",(0,r.jsx)(s.br,{}),"\n","Selects the type of shadows that should be cast from this prop_static."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Baked & Dynamic (",(0,r.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Only Baked (",(0,r.jsx)(s.code,{children:"3"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Only Dynamic (",(0,r.jsx)(s.code,{children:"2"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["None (",(0,r.jsx)(s.code,{children:"1"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Emissive"})," (",(0,r.jsx)(s.code,{children:"emissive"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","Allow this prop to emit lighting. Note that this only works on materials with Self Illum parameters, and is only visible in the GPU Path Tracing Preview and in the final lightmap bake."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Emissive Boost"})," (",(0,r.jsx)(s.code,{children:"emissive_lighting_boost"}),") <",(0,r.jsx)(s.code,{children:"Float"}),">",(0,r.jsx)(s.br,{}),"\n","Used to boost emissive lighting from a mesh. Note that boosting emissive on smaller meshes can create more lighting artifacts/noise."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Lightmap Scale Bias"})," (",(0,r.jsx)(s.code,{children:"lightmapscalebias"}),") <",(0,r.jsx)(s.code,{children:"Choices"}),">",(0,r.jsx)(s.br,{}),"\n","Used to scale the resolution of the lightmap for this mesh."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Scale down by 8 (",(0,r.jsx)(s.code,{children:"-3"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Scale down by 4 (",(0,r.jsx)(s.code,{children:"-2"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Scale down by 2 (",(0,r.jsx)(s.code,{children:"-1"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Default (no scale) (",(0,r.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Scale up by 2 (",(0,r.jsx)(s.code,{children:"1"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Scale up by 4 (",(0,r.jsx)(s.code,{children:"2"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Scale up by 8 (",(0,r.jsx)(s.code,{children:"3"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Bake As Double-Sided"})," (",(0,r.jsx)(s.code,{children:"bakelightdoublesided"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","Bakes the mesh as if it were double-sided geometry in the lightmapper. Useful on geometry with 'Render Backfaces' enabled via it's material (such as foliage). When the lightmapper sees many and/or large backfaces it will invalidate lightmap samples as an optimization, which can lead to lightmap errors/reduced quality in some circumstances."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Vis Occluder"})," (",(0,r.jsx)(s.code,{children:"visoccluder"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","If true this geometry is used as an occluder for precomputed visibility. As a rule this geometry should be as simplistic as possible"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Material Override"})," (",(0,r.jsx)(s.code,{children:"materialoverride"}),") <",(0,r.jsx)(s.code,{children:"Material"}),">",(0,r.jsx)(s.br,{}),"\n","This will override all materials on a selected mesh with a specific material"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Render LOD"})," (",(0,r.jsx)(s.code,{children:"lodlevel"}),") <",(0,r.jsx)(s.code,{children:"LodLevel"}),">",(0,r.jsx)(s.br,{}),"\n","Auto for standard LOD behaviour, or select an explicit LOD to use. Note that LODs take up more room in the lightmap and do not merge, potentially making them less performant if used on many objects (Set to Auto)."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Start Fade Dist"})," (",(0,r.jsx)(s.code,{children:"fademindist"}),") <",(0,r.jsx)(s.code,{children:"Float"}),">",(0,r.jsx)(s.br,{}),"\n","Distance at which the prop starts to fade (-1 = use fademaxdist)."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"End Fade Dist"})," (",(0,r.jsx)(s.code,{children:"fademaxdist"}),") <",(0,r.jsx)(s.code,{children:"Float"}),">",(0,r.jsx)(s.br,{}),"\n","Maximum distance at which the prop is visible (0 = don't fade out)."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Force Bake To World"})," (",(0,r.jsx)(s.code,{children:"baketoworld"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","If true mesh will be baked/merged into the world geometry of the map so that the model is not referenced at runtime. Use this if you want light probed static meshes to merge"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Disable Mesh Merging"})," (",(0,r.jsx)(s.code,{children:"disablemerging"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","If true this will not be merged with other geometry during map compile (reduces rendering efficiency)."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Alpha"})," (",(0,r.jsx)(s.code,{children:"renderamt"}),") <",(0,r.jsx)(s.code,{children:"Integer"}),">",(0,r.jsx)(s.br,{}),"\n","Alpha of the fade, where 0 = fully transparent and 255 = fully opaque."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Render to Cubemaps"})," (",(0,r.jsx)(s.code,{children:"rendertocubemaps"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","If true, this geometry renders into baked cube maps"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Render with Dynamic Objects"})," (",(0,r.jsx)(s.code,{children:"renderwithdynamic"}),") <",(0,r.jsx)(s.code,{children:"Boolean"}),">",(0,r.jsx)(s.br,{}),"\n","Render this object with other dynamic objects"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Grass Exclusion Radius"})," (",(0,r.jsx)(s.code,{children:"grass_exclusion_radius"}),") <",(0,r.jsx)(s.code,{children:"Float"}),">",(0,r.jsx)(s.br,{}),"\n","Don't grow grass within this radius."]}),"\n"]}),"\n"]})]})]})}function a(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);