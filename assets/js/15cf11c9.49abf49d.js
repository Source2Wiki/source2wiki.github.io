"use strict";(self.webpackChunksource_2_wiki=self.webpackChunksource_2_wiki||[]).push([[58064],{19806:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>h,default:()=>a,frontMatter:()=>d,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/choicenode","title":"Choice Anim Node","description":"This node randomly chooses one of its children to play","source":"@site/docs/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/choicenode.mdx","sourceDirName":"EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation","slug":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/choicenode","permalink":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/choicenode","draft":false,"unlisted":false,"editUrl":"https://github.com/Source2Wiki/Source2Wiki/blob/master/docs/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/choicenode.mdx?plain=1","tags":[],"version":"current","frontMatter":{"description":"This node randomly chooses one of its children to play","title":"Choice Anim Node"},"sidebar":"tutorialSidebar","previous":{"title":"Animation Clip Node","permalink":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/animationclip"},"next":{"title":"Motion Matching","permalink":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/motionmatchingnode"}}');var t=i(74848),s=i(28453);const d={description:"This node randomly chooses one of its children to play",title:"Choice Anim Node"},h=void 0,r={},c=[{value:"Weights",id:"weights",level:2},{value:"Methods",id:"methods",level:2},{value:"Change Selection",id:"change-selection",level:2},{value:"Blend Methods",id:"blend-methods",level:2}];function l(e){const n={h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Choice node will choose one of it's children to be played randomly based on methods."}),"\n",(0,t.jsx)(n.p,{children:"The options can blend from old choice to a new one when a new choice has been made and a node has not been reset."}),"\n",(0,t.jsx)(n.p,{children:"There is an option to control the duration for that named Blend Duration, and there is an option to reset children when they get selected, along with a crossfade option."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"choice node",src:i(77695).A+"",title:"Choice Node",width:"558",height:"248"})}),"\n",(0,t.jsx)(n.h2,{id:"weights",children:"Weights"}),"\n",(0,t.jsxs)(n.p,{children:["Weights are based on probability if it will be selected, they are NOT percentage based, they are relative to the sum of all the weights for all the options.\n",(0,t.jsx)(n.img,{alt:"choice node",src:i(42762).A+"",title:"Choice Node",width:"553",height:"466"})]}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.p,{children:"There are 4 methods to pick a child node."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"WeightedRandom:"})," Randomly choose the next child based on their weighting.  Can pick the same child twice in a row. ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"WeightedRandomNoRepeat:"})," Same as WeightedRandom, but prevents the same child from being chosen twice in a row. ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"Iterate:"})," The next selected child is the one that comes after the current one. ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"IterateRandom:"})," Randomly choose between the children that have not been played, and don't repeat any children until they've all been played.  ",(0,t.jsx)("br",{})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"change-selection",children:"Change Selection"}),"\n",(0,t.jsx)(n.p,{children:"And 3 methods to determine when the node selects a new child."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"OnReset:"})," Only make a new choice when the node is reset by its parent. ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"OnCycleEnd:"})," Make a new selection when the current one has finished playing.  ",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"OnResetOrCycleEnd:"})," Make a new choice when the node is reset or when the current selecion's cycle ends. ",(0,t.jsx)("br",{})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"blend-methods",children:"Blend Methods"}),"\n",(0,t.jsx)(n.p,{children:"Methods for how the blend time is chosen when blending between choices."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"Single Blend Time:"})," a single value specified in the node settings is used for all blends, not match which choice item is picked.",(0,t.jsx)("br",{})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("b",{children:"Per-Choice Blend Times:"})," The blend time of the new selection is used.",(0,t.jsx)("br",{})]}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>h});var o=i(96540);const t={},s=o.createContext(t);function d(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),o.createElement(s.Provider,{value:n},e.children)}},42762:(e,n,i)=>{i.d(n,{A:()=>o});const o=i.p+"assets/images/choicenode_choices-88c629af65831f89fde784a86b1df37b.png"},77695:(e,n,i)=>{i.d(n,{A:()=>o});const o=i.p+"assets/images/choicenode_main-9f7780babf000b0cf32c616d38c391e9.png"}}]);