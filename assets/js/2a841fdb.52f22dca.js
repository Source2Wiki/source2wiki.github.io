"use strict";(self.webpackChunksource_2_wiki=self.webpackChunksource_2_wiki||[]).push([[72355],{21064:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/motionmatching_cs2-eea8cb4163465b762c0486d2fbf29aa6.png"},28453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>s});var n=i(96540);const o={},a=n.createContext(o);function l(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),n.createElement(a.Provider,{value:t},e.children)}},74273:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/motionmatchingnode","title":"Motion Matching","description":"Continuously picks the best clip of animation to play from a given set of animations based on a defined set of cost metrics","source":"@site/docs/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/motionmatchingnode.mdx","sourceDirName":"EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation","slug":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/motionmatchingnode","permalink":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/motionmatchingnode","draft":false,"unlisted":false,"editUrl":"https://github.com/Source2Wiki/Source2Wiki/blob/master/docs/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/motionmatchingnode.mdx?plain=1","tags":[],"version":"current","frontMatter":{"description":"Continuously picks the best clip of animation to play from a given set of animations based on a defined set of cost metrics","title":"Motion Matching"},"sidebar":"tutorialSidebar","previous":{"title":"Choice Anim Node","permalink":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/choicenode"},"next":{"title":"Selector Anim Node","permalink":"/EngineTools/AnimgraphEditor/AnimgraphEditorNodes/Animation/selectornode"}}');var o=i(74848),a=i(28453);const l={description:"Continuously picks the best clip of animation to play from a given set of animations based on a defined set of cost metrics",title:"Motion Matching"},s=void 0,r={},c=[{value:"Clips",id:"clips",level:2},{value:"Core parameters",id:"core-parameters",level:2},{value:"Sample Rate",id:"sample-rate",level:3},{value:"Search Every Update",id:"search-every-update",level:2},{value:"Blend Time",id:"blend-time",level:2},{value:"Selection Threshold",id:"selection-threshold",level:2},{value:"Re-Selection Time Window",id:"re-selection-time-window",level:2},{value:"Lock Selection When Waning",id:"lock-selection-when-waning",level:2},{value:"Enable Rotation Correction",id:"enable-rotation-correction",level:2},{value:"Enable Goal Assist",id:"enable-goal-assist",level:2},{value:"Enable Distance Scaling",id:"enable-distance-scaling",level:2},{value:"Motion Matching Metrics",id:"motion-matching-metrics",level:2},{value:"Bone Position Metric",id:"bone-position-metric",level:3},{value:"Bone Velocity Metric",id:"bone-velocity-metric",level:3},{value:"Current Rotation Velocity Metric",id:"current-rotation-velocity-metric",level:3},{value:"Current Velocity Metric",id:"current-velocity-metric",level:3},{value:"Distance Remaining Metric",id:"distance-remaining-metric",level:3},{value:"Maximum Tracked Distance",id:"maximum-tracked-distance",level:4},{value:"Filter By Fixed Distance",id:"filter-by-fixed-distance",level:4},{value:"Min Distance",id:"min-distance",level:4},{value:"Filter By Goal Distance",id:"filter-by-goal-distance",level:4},{value:"Goal Filter Start Distance",id:"goal-filter-start-distance",level:4},{value:"Filter By Goal Overshoot",id:"filter-by-goal-overshoot",level:4},{value:"Max Goal Overshoot Scale",id:"max-goal-overshoot-scale",level:4},{value:"Foot Cycle Metric",id:"foot-cycle-metric",level:3},{value:"Foot",id:"foot",level:4},{value:"Foot Position Metric",id:"foot-position-metric",level:3},{value:"Foot",id:"foot-1",level:4},{value:"Ignore Slope",id:"ignore-slope",level:4},{value:"Future Facing Metric",id:"future-facing-metric",level:3},{value:"Distance",id:"distance",level:4},{value:"Time",id:"time",level:4},{value:"Future Velocity Metric",id:"future-velocity-metric",level:3},{value:"Distance",id:"distance-1",level:4},{value:"Stopping Distance",id:"stopping-distance",level:4},{value:"Mode",id:"mode",level:4},{value:"Path Metric",id:"path-metric",level:3},{value:"Distance",id:"distance-2",level:4},{value:"Sample Times",id:"sample-times",level:4},{value:"Extrapolate Movement",id:"extrapolate-movement",level:4},{value:"Min Extrapolation Speed",id:"min-extrapolation-speed",level:4}];function h(e){const t={h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Motion Matching"}),"\n",(0,o.jsx)(t.p,{children:"Continuously picks the best clip of animation to play from a given set of animations based on a defined set of cost metrics."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"motion matching node",src:i(21064).A+"",title:"Motion Matching node",width:"1311",height:"767"})}),"\n",(0,o.jsx)(t.h2,{id:"clips",children:"Clips"}),"\n",(0,o.jsx)(t.p,{children:"For Motion Matching Clips, not only an amount of clips based on cost metrics controlled with parameters can be selected, but also a Motion Graph can be used.\nMotion Graph can use clips and a 1D Blend that uses the Motion Graph Parameter. More samples are defined, more your motion matching node and graph become expensive."}),"\n",(0,o.jsx)(t.h2,{id:"core-parameters",children:"Core parameters"}),"\n",(0,o.jsx)(t.h3,{id:"sample-rate",children:"Sample Rate"}),"\n",(0,o.jsx)(t.p,{children:"When the Sampling method is set to Uniform, each clip in the motion set is sampled at this rate to determine the list of possible entry points into the clip that will be included in the motion search."}),"\n",(0,o.jsx)(t.h2,{id:"search-every-update",children:"Search Every Update"}),"\n",(0,o.jsx)(t.h2,{id:"blend-time",children:"Blend Time"}),"\n",(0,o.jsx)(t.p,{children:"The amount of time to take to blend to a new clip/entry point once its chosen."}),"\n",(0,o.jsx)(t.h2,{id:"selection-threshold",children:"Selection Threshold"}),"\n",(0,o.jsx)(t.p,{children:"Any new selection must exceed the score of the current clip by this amount to be chosen as the new clip."}),"\n",(0,o.jsx)(t.h2,{id:"re-selection-time-window",children:"Re-Selection Time Window"}),"\n",(0,o.jsx)(t.p,{children:"This setting controls how much time before and after the current clip's cycle is off limits for new selections."}),"\n",(0,o.jsx)(t.p,{children:"Sometimes the motion matching search will find that the best new sample the jump to is really close to the current time of the current clip, which cause the motion to appear to stutter and get stuck in short loops."}),"\n",(0,o.jsx)(t.p,{children:"To prevent this, the system prevents new selections from samples within a user-defined window of time around the current selection."}),"\n",(0,o.jsx)(t.h2,{id:"lock-selection-when-waning",children:"Lock Selection When Waning"}),"\n",(0,o.jsx)(t.p,{children:'When true, the selection will not get updated while this node is being blended out of (aka: "Waning")'}),"\n",(0,o.jsx)(t.h2,{id:"enable-rotation-correction",children:"Enable Rotation Correction"}),"\n",(0,o.jsx)(t.h2,{id:"enable-goal-assist",children:"Enable Goal Assist"}),"\n",(0,o.jsx)(t.p,{children:"Toggles Goal Assist on and off."}),"\n",(0,o.jsx)(t.p,{children:"Goal Assist will force the motion matching system to pick a new clip if the entity is near the goal waypoint but the currently selected clip won't move the entity far enough to reach the goal.  Helps avoid premature stops."}),"\n",(0,o.jsx)(t.h2,{id:"enable-distance-scaling",children:"Enable Distance Scaling"}),"\n",(0,o.jsx)(t.p,{children:"Toggles Distance Scaling on and off."}),"\n",(0,o.jsx)(t.p,{children:"If the current clip is not a looping animation, Distance Scaling helps the the clip stop exactly at the goal at the end of the path by scaling the root motion of the clip."}),"\n",(0,o.jsx)(t.h2,{id:"motion-matching-metrics",children:"Motion Matching Metrics"}),"\n",(0,o.jsx)(t.h3,{id:"bone-position-metric",children:"Bone Position Metric"}),"\n",(0,o.jsx)(t.h3,{id:"bone-velocity-metric",children:"Bone Velocity Metric"}),"\n",(0,o.jsx)(t.p,{children:"Search metric that compares the current velocity of a bone on the entity to the velocity of that bone in the clips."}),"\n",(0,o.jsx)(t.h3,{id:"current-rotation-velocity-metric",children:"Current Rotation Velocity Metric"}),"\n",(0,o.jsx)(t.h3,{id:"current-velocity-metric",children:"Current Velocity Metric"}),"\n",(0,o.jsx)(t.h3,{id:"distance-remaining-metric",children:"Distance Remaining Metric"}),"\n",(0,o.jsx)(t.p,{children:"Search for clips that match the distance remaining along the path."}),"\n",(0,o.jsx)(t.h4,{id:"maximum-tracked-distance",children:"Maximum Tracked Distance"}),"\n",(0,o.jsx)(t.p,{children:"Clip samples that have more than this distance remaining before the end of the clip will have the value capped.  That way all samples with this distance or greater are weighted equally in the search."}),"\n",(0,o.jsx)(t.h4,{id:"filter-by-fixed-distance",children:"Filter By Fixed Distance"}),"\n",(0,o.jsx)(t.p,{children:"Enable this option to filter out any samples that have less than a certain amount of movement left in the clip."}),"\n",(0,o.jsx)(t.h4,{id:"min-distance",children:"Min Distance"}),"\n",(0,o.jsx)(t.p,{children:"The threshhold for the fixed distance filter"}),"\n",(0,o.jsx)(t.h4,{id:"filter-by-goal-distance",children:"Filter By Goal Distance"}),"\n",(0,o.jsx)(t.p,{children:"Toggle whether or not to filter out any samples that would not take the entity far enough to reach the goal"}),"\n",(0,o.jsx)(t.h4,{id:"goal-filter-start-distance",children:"Goal Filter Start Distance"}),"\n",(0,o.jsx)(t.p,{children:"Don't start filtering clips until the entity is at least this distance from the goal"}),"\n",(0,o.jsx)(t.h4,{id:"filter-by-goal-overshoot",children:"Filter By Goal Overshoot"}),"\n",(0,o.jsx)(t.p,{children:"Enable this option to filter out samples that would take the entity past its goal"}),"\n",(0,o.jsx)(t.h4,{id:"max-goal-overshoot-scale",children:"Max Goal Overshoot Scale"}),"\n",(0,o.jsx)(t.p,{children:"Applies a scale to the goal distance that is used to filter by goal overshoot.  Using a scale rather than an absolute value allows the filter be become more aggressive as the entity gets closer to the goal."}),"\n",(0,o.jsx)(t.h3,{id:"foot-cycle-metric",children:"Foot Cycle Metric"}),"\n",(0,o.jsx)(t.p,{children:"Search for clips where the foot cycle matches the entity's current foot cycle."}),"\n",(0,o.jsx)(t.h4,{id:"foot",children:"Foot"}),"\n",(0,o.jsx)(t.p,{children:"List of the feet to include in the search"}),"\n",(0,o.jsx)(t.h3,{id:"foot-position-metric",children:"Foot Position Metric"}),"\n",(0,o.jsx)(t.p,{children:"Match the current position of the entity's foot with the position of the foot at the start of the clip samples.  Only works if feet are defined on the model and the graph is using the Strider system."}),"\n",(0,o.jsx)(t.h4,{id:"foot-1",children:"Foot"}),"\n",(0,o.jsx)(t.p,{children:"The feet positions to check"}),"\n",(0,o.jsx)(t.h4,{id:"ignore-slope",children:"Ignore Slope"}),"\n",(0,o.jsx)(t.p,{children:"The Strider system supports traversing uneven terrain so the current position of the feet may be raised if the character is standing on a slope.  This can create bad matches if the data set consists of only flat-ground animations.  So this option will adjust the position of the feet to where they would be if the entity was standing on flat ground before performing the search."}),"\n",(0,o.jsx)(t.h3,{id:"future-facing-metric",children:"Future Facing Metric"}),"\n",(0,o.jsx)(t.p,{children:"Compares the desired future orientation of the entity with the orientation that each clip sample would rotate the entity to after it has traveled a given distance."}),"\n",(0,o.jsx)(t.h4,{id:"distance",children:"Distance"}),"\n",(0,o.jsx)(t.p,{children:"When calculating the future facing value for each sample, advance the animation until the entity has moved this far and use the value at this point."}),"\n",(0,o.jsx)(t.h4,{id:"time",children:"Time"}),"\n",(0,o.jsx)(t.h3,{id:"future-velocity-metric",children:"Future Velocity Metric"}),"\n",(0,o.jsx)(t.p,{children:"Compares the desired future velocity of the entity with the velocity of each clip sample after it has traveled a given distance."}),"\n",(0,o.jsx)(t.h4,{id:"distance-1",children:"Distance"}),"\n",(0,o.jsx)(t.p,{children:"When calculating the future facing value for each sample, advance the animation until the entity has moved this far and use the value at this point."}),"\n",(0,o.jsx)(t.h4,{id:"stopping-distance",children:"Stopping Distance"}),"\n",(0,o.jsx)(t.p,{children:"When the entity is within this distance of the goal, ramp down the target velocity to match so that the velocity is zero at the goal."}),"\n",(0,o.jsx)(t.h4,{id:"mode",children:"Mode"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Direction Only"}),"\n",(0,o.jsx)(t.li,{children:"Magnitude Only"}),"\n",(0,o.jsx)(t.li,{children:"Direction and Magnitude"}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"path-metric",children:"Path Metric"}),"\n",(0,o.jsx)(t.p,{children:"Search for clip samples that most closely match the shape of the current path."}),"\n",(0,o.jsx)(t.h4,{id:"distance-2",children:"Distance"}),"\n",(0,o.jsx)(t.p,{children:"The farthest distance along the path to check."}),"\n",(0,o.jsx)(t.h4,{id:"sample-times",children:"Sample Times"}),"\n",(0,o.jsx)(t.p,{children:"These items are the samples along the path, defined by their distance from the entity's current position."}),"\n",(0,o.jsx)(t.p,{children:"The values are a scale applied to  Distance.  So for example if Distance is 100, and a Sample Time is 0.5, then the metric will include a check between the position 50 units along the path with the position the entity would be if it moved (up to) 50 units with each clip."}),"\n",(0,o.jsx)(t.h4,{id:"extrapolate-movement",children:"Extrapolate Movement"}),"\n",(0,o.jsx)(t.p,{children:"Some clips don't loop, but don't end with the entity coming to a stop, either.  So when this option is enabled, the metric will guess at the future position of the entity if it were to continue in the direction and speed at the end of the clip, and use those extrapolated values when calculating the samples of the clip."}),"\n",(0,o.jsx)(t.h4,{id:"min-extrapolation-speed",children:"Min Extrapolation Speed"}),"\n",(0,o.jsx)(t.p,{children:"Some animation clips actually DO bring the entity to a stop, but the velocity on the last frame isn't quite zero.  So this value allows you to specify a minimum speed that the entity needs to be moving at the end of a clip for this metric to do any extrapolation of the future position."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);