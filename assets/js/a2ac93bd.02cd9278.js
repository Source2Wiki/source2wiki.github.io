"use strict";(self.webpackChunksource_2_wiki=self.webpackChunksource_2_wiki||[]).push([[18276,60380,66620,96247,97632],{18014:(e,n,s)=>{s.d(n,{A:()=>C});var i=s(96540),r=s(34164),l=s(23104),t=s(56347),o=s(205),a=s(57485),d=s(31682),c=s(70679);function h(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function x(e){const{values:n,children:s}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:s,default:i}})=>({value:e,label:n,attributes:s,default:i}))}(s);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,s])}function u({value:e,tabValues:n}){return n.some(n=>n.value===e)}function j({queryString:e=!1,groupId:n}){const s=(0,t.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,a.aZ)(r),(0,i.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(s.location.search);n.set(r,e),s.replace({...s.location,search:n.toString()})},[r,s])]}function p(e){const{defaultValue:n,queryString:s=!1,groupId:r}=e,l=x(e),[t,a]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const s=n.find(e=>e.default)??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:l})),[d,h]=j({queryString:s,groupId:r}),[p,m]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[s,r]=(0,c.Dv)(n);return[s,(0,i.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),b=(()=>{const e=d??p;return u({value:e,tabValues:l})?e:null})();(0,o.A)(()=>{b&&a(b)},[b]);return{selectedValue:t,selectValue:(0,i.useCallback)(e=>{if(!u({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);a(e),h(e),m(e)},[h,m,l]),tabValues:l}}var m=s(92303);const b="tabList__CuJ",g="tabItem_LNqP";var f=s(74848);function v({className:e,block:n,selectedValue:s,selectValue:i,tabValues:t}){const o=[],{blockElementScrollPositionUntilNextRender:a}=(0,l.a_)(),d=e=>{const n=e.currentTarget,r=o.indexOf(n),l=t[r].value;l!==s&&(a(n),i(l))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const s=o.indexOf(e.currentTarget)+1;n=o[s]??o[0];break}case"ArrowLeft":{const s=o.indexOf(e.currentTarget)-1;n=o[s]??o[o.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:t.map(({value:e,label:n,attributes:i})=>(0,f.jsx)("li",{role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,ref:e=>{o.push(e)},onKeyDown:c,onClick:d,...i,className:(0,r.A)("tabs__item",g,i?.className,{"tabs__item--active":s===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:s}){const l=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=l.find(e=>e.props.value===s);return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:l.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==s}))})}function _(e){const n=p(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",b),children:[(0,f.jsx)(v,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function w(e){const n=(0,m.A)();return(0,f.jsx)(_,{...e,children:h(e.children)},String(n))}const k="tabItem_Ymn6";function T({children:e,hidden:n,className:s}){return(0,f.jsx)("div",{role:"tabpanel",className:(0,r.A)(k,s),hidden:n,children:e})}var E=s(94334);const C=e=>{const n={};if(Object.entries(e).forEach(([e,s])=>{E.kx[e]&&s&&(i.isValidElement(s)||"object"==typeof s)&&(n[e]=s)}),!n||"object"!=typeof n)throw new Error("GameTabs: No valid game content found in props");const s=Object.entries(n);if(0===s.length)throw new Error("GameTabs element without any tabs");return(0,f.jsx)(w,{queryString:"game",className:"game-tabs",children:s.map(([e,n])=>{const s=E.kx[e];return s&&n?(0,f.jsx)(T,{value:e,label:s.PrettyName,attributes:{className:e},children:n},e):null})})}},21082:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"type":"mdx","permalink":"/Entities/worldspawn-cs2","source":"@site/src/pages/Entities/worldspawn-cs2.mdx","description":"\x3c!---","frontMatter":{"hide_table_of_contents":true},"unlisted":false}');var r=s(74848),l=s(28453);const t={hide_table_of_contents:!0},o=void 0,a={},d=[];function c(e){const n={br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Mesh Entity"}),"\n",(0,r.jsx)(n.p,{children:"This is the world entity. Each map can only contain one, and it's automatically created for you."}),"\n",(0,r.jsxs)(s,{open:!0,children:[(0,r.jsx)("summary",{children:(0,r.jsx)("h2",{children:"Keyvalues"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Name"})," (",(0,r.jsx)(n.code,{children:"targetname"}),") <",(0,r.jsx)(n.code,{children:"TargetSource"}),">",(0,r.jsx)(n.br,{}),"\n","The name that other entities refer to this entity by."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"SkyBox Texture Name"})," (",(0,r.jsx)(n.code,{children:"skyname"}),") <",(0,r.jsx)(n.code,{children:"String"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In"})," (",(0,r.jsx)(n.code,{children:"startdark"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In Color (R G B)"})," (",(0,r.jsx)(n.code,{children:"startcolor"}),") <",(0,r.jsx)(n.code,{children:"Color255"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precomputed Visibility"})," (",(0,r.jsx)(n.code,{children:"pvstype"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disabled"}),"\n",(0,r.jsx)(n.li,{children:"Test map (open space, no skybox)"}),"\n",(0,r.jsx)(n.li,{children:"Full visibility solve"}),"\n",(0,r.jsx)(n.li,{children:"Partitioned solve (large map volume)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"New Level Unit"})," (",(0,r.jsx)(n.code,{children:"newunit"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No, keep current"}),"\n",(0,r.jsx)(n.li,{children:"Yes, clear previous levels"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Start Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"maxpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"minpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Maximum Lightmap Resolution"})," (",(0,r.jsx)(n.code,{children:"max_lightmap_resolution"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No Maximum"}),"\n",(0,r.jsx)(n.li,{children:"512"}),"\n",(0,r.jsx)(n.li,{children:"1024"}),"\n",(0,r.jsx)(n.li,{children:"2048"}),"\n",(0,r.jsx)(n.li,{children:"4096"}),"\n",(0,r.jsx)(n.li,{children:"8192"}),"\n",(0,r.jsx)(n.li,{children:"16384"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lightmap Queries"})," (",(0,r.jsx)(n.code,{children:"lightmap_queries"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Generates data which can be used to lookup lightmap UVs at a given position, useful for high-fidelity illumination of bullet decals on lightmapped geometry."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rebake Option"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_rebake_option"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)("b",{children:"Cleanup"}),": Reverb bake is disabled. Baked data will be cleaned up during map compile in Hammer or mapbuilder.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Manual"}),": Reverb needs to be baked manually. Baked data is added or updated during map compile in Hammer but untouched by mapbuilder.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Auto"}),": Reverb is baked automatically during map compile. Baked data is added or updated during map compile in Hammer or mapbuilder."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cleanup"}),"\n",(0,r.jsx)(n.li,{children:"Manual"}),"\n",(0,r.jsx)(n.li,{children:"Auto"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Generation Type"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_generation_type"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)("b",{children:"Automatic, Everywhere"}),": When baking, probes will be generated to cover the entire map.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Automatic, Use Probe Generation Volumes"}),": When baking, probes will only be generated within Probe Generation Volumes that have been explicitly placed in the map.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Manual"}),": When baking, probes will not be generated. Only probes that have been manually placed in the map will be used."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatic, Everywhere"}),"\n",(0,r.jsx)(n.li,{children:"Automatic, Use Probe Generation Volumes"}),"\n",(0,r.jsx)(n.li,{children:"Manual"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Using Probe Exclusion Volumes"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_filter_volumes"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Don't generate probes inside Probe Exclusion Volumes that have been placed in the map.",(0,r.jsx)("br",{}),"(Only used if Generation Type is set to Automatic, Everywhere.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Using NavMesh"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_filter_navmesh"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Only generate probes that are near the nav mesh.",(0,r.jsx)("br",{}),"(Only used if Generation Type is set to Automatic, Everywhere.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Grid Spacing"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_grid_spacing"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The horizontal distance (in meters) between adjacent probes."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Height Above Floor"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_height_above_floor"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The height (in meters) above the floor at which probes should be placed.."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Rays"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_rays"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","The number of rays traced from the listener when baking reflections or reverb. Increasing this value results in more accurate reflections, at the cost of increased bake times."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Bounces"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_bounces"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","The number of times each ray traced from the listener is reflected when baking reflections or reverb. Increasing this value results in longer, more accurate reverb tails, at the cost of increased bake times."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Duration"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_ir_duration"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The duration (in seconds) of the IRs generated when baking reflections or reverb. Increasing this value results in longer, more accurate reverb tails, at the cost of increased disk space usage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Ambisonic Order"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_ambisonic_order"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","The Ambisonic order of the IRs generated when baking reflections or reverb. Increasing this value results in more accurate directional variation of reflected sound, at the cost of increased disk space usage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Enable Clustering"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_clustering_enable"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Reduces the number of probes generated by combining nearby probes that are likely to have similar reverbs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cube Map Resolution"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_clustering_cubemap_resolution"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","Number of rays traced per side for each face of the depth cube map computed for each probe."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Depth Similarity Threshold"})," (",(0,r.jsx)(n.code,{children:"steamaudio_reverb_clustering_depth_threshold"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","If average depth map values at two probes are within this distance (in meters), then the probes are considered similar."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rebake Option"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_rebake_option"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)("b",{children:"Cleanup"}),": Pathing bake is disabled. Baked data will be cleaned up during map compile in Hammer or mapbuilder.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Manual"}),": Pathing needs to be baked manually. Baked data is added or updated during map compile in Hammer but untouched by mapbuilder.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Auto"}),": Pathing is baked automatically during map compile. Baked data is added or updated during map compile in Hammer or mapbuilder."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cleanup"}),"\n",(0,r.jsx)(n.li,{children:"Manual"}),"\n",(0,r.jsx)(n.li,{children:"Auto"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Generation Type"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_generation_type"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)("b",{children:"Automatic, Everywhere"}),": When baking, probes will be generated to cover the entire map.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Automatic, Use Probe Generation Volumes"}),": When baking, probes will only be generated within Probe Generation Volumes that have been explicitly placed in the map.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Manual"}),": When baking, probes will not be generated. Only probes that have been manually placed in the map will be used."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatic, Everywhere"}),"\n",(0,r.jsx)(n.li,{children:"Automatic, Use Probe Generation Volumes"}),"\n",(0,r.jsx)(n.li,{children:"Manual"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Using Probe Exclusion Volumes"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_filter_volumes"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Don't generate probes inside Probe Exclusion Volumes that have been placed in the map.",(0,r.jsx)("br",{}),"(Only used if Generation Type is set to Automatic, Everywhere.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Using NavMesh"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_filter_navmesh"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Only generate probes that are near the nav mesh.",(0,r.jsx)("br",{}),"(Only used if Generation Type is set to Automatic, Everywhere.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Grid Spacing"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_grid_spacing"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The horizontal distance (in meters) between adjacent probes."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Height Above Floor"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_height_above_floor"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The height (in meters) above the floor at which probes should be placed.."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Visibilty Samples"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_visibility_samples"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","Number of point samples to use around each probe when testing whether one probe can see another. To determine if two probes are mutually visible, rays are traced from each point sample of the first probe, to every other point sample of the second probe. Increasing this value prevents paths from being considered occluded by small objects, at the cost of increased bake times."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Visibility Radius"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_visibility_radius"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of this radius (in meters), and point samples are generated within this sphere."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Visibility Threshold"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_visibility_threshold"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that are unoccluded must be greater than this threshold for the pair of probes to be considered mutually visible."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baking Path Range"})," (",(0,r.jsx)(n.code,{children:"steamaudio_pathing_visibility_pathrange"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","If the distance (in meters) between two probes is greater than this value, the probes are considered to not have any path between them. Increasing this value allows sound to propagate over greater distances, at the cost of increased bake times and memory usage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rebake Option"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_rebake_option"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)("b",{children:"Cleanup"}),": Custom bake is disabled. Baked data will be cleaned up during map compile in Hammer or mapbuilder.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Manual"}),": Custom data needs to be baked manually. Baked data is added or updated during map compile in Hammer but untouched by mapbuilder.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Auto"}),": Custom data is baked automatically during map compile. Baked data is added or updated during map compile in Hammer or mapbuilder."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cleanup"}),"\n",(0,r.jsx)(n.li,{children:"Manual"}),"\n",(0,r.jsx)(n.li,{children:"Auto"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Generation Type"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_generation_type"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)("b",{children:"Automatic, Everywhere"}),": When baking, probes will be generated to cover the entire map.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Automatic, Use Probe Generation Volumes"}),": When baking, probes will only be generated within Probe Generation Volumes that have been explicitly placed in the map.",(0,r.jsx)("br",{}),(0,r.jsx)("b",{children:"Manual"}),": When baking, probes will not be generated. Only probes that have been manually placed in the map will be used."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatic, Everywhere"}),"\n",(0,r.jsx)(n.li,{children:"Automatic, Use Probe Generation Volumes"}),"\n",(0,r.jsx)(n.li,{children:"Manual"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Using Probe Exclusion Volumes"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_filter_volumes"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Don't generate probes inside Probe Exclusion Volumes that have been placed in the map.",(0,r.jsx)("br",{}),"(Only used if Generation Type is set to Automatic, Everywhere.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Filter Using NavMesh"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_filter_navmesh"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Only generate probes that are near the nav mesh.",(0,r.jsx)("br",{}),"(Only used if Generation Type is set to Automatic, Everywhere.)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Grid Spacing"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_grid_spacing"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The horizontal distance (in meters) between adjacent probes."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Height Above Floor"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_height_above_floor"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","The height (in meters) above the floor at which probes should be placed.."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bake Occlusion"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_bake_occlusion"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Bake custom occlusion data between probe pairs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bake Dimensions"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_bake_dimensions"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Bake occlusion dimensions data (size and inside outside) per probe."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bake Materials"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_bake_materials"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Bake custom materials data (top 3 nearby materials) per probe."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Occlusion: Simulate Pathing"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_occlusion_pathing"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Simulate pathing when computing baked occlusion."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Occlusion: Simulate Reflection"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_occlusion_reflection"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Simulate reflections when computing baked occlusion."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Occlusion: Reflection Num Rays"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_occlusion_reflection_rays"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","Number of rays to simulate reflections."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Occlusion: Reflection Bounces"})," (",(0,r.jsx)(n.code,{children:"steamaudio_customdata_occlusion_reflection_bounces"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","Number of bounces to simulate reflections."]}),"\n"]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},27592:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"type":"mdx","permalink":"/Entities/worldspawn-steamvr","source":"@site/src/pages/Entities/worldspawn-steamvr.mdx","description":"\x3c!---","frontMatter":{"hide_table_of_contents":true},"unlisted":false}');var r=s(74848),l=s(28453);const t={hide_table_of_contents:!0},o=void 0,a={},d=[];function c(e){const n={br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Mesh Entity"}),"\n",(0,r.jsx)(n.p,{children:"This is the world entity. Each map can only contain one, and it's automatically created for you."}),"\n",(0,r.jsxs)(s,{open:!0,children:[(0,r.jsx)("summary",{children:(0,r.jsx)("h2",{children:"Keyvalues"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Name"})," (",(0,r.jsx)(n.code,{children:"targetname"}),") <",(0,r.jsx)(n.code,{children:"TargetSource"}),">",(0,r.jsx)(n.br,{}),"\n","The name that other entities refer to this entity by."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"SkyBox Texture Name"})," (",(0,r.jsx)(n.code,{children:"skyname"}),") <",(0,r.jsx)(n.code,{children:"String"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In"})," (",(0,r.jsx)(n.code,{children:"startdark"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precomputed Visibility"})," (",(0,r.jsx)(n.code,{children:"pvstype"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disabled"}),"\n",(0,r.jsx)(n.li,{children:"Test map (open space, no skybox)"}),"\n",(0,r.jsx)(n.li,{children:"Full visibility solve"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"New Level Unit"})," (",(0,r.jsx)(n.code,{children:"newunit"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No, keep current"}),"\n",(0,r.jsx)(n.li,{children:"Yes, clear previous levels"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Start Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"maxpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"minpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"VR Chaperone"})," (",(0,r.jsx)(n.code,{children:"vrchaperone"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Chaperone"}),"\n",(0,r.jsx)(n.li,{children:"Chaperone + Safe Zone"}),"\n",(0,r.jsx)(n.li,{children:"No Chaperone"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"VR Movement"})," (",(0,r.jsx)(n.code,{children:"vrmovement"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"None"}),"\n",(0,r.jsx)(n.li,{children:"Teleport"}),"\n",(0,r.jsx)(n.li,{children:"Teleport (w/non-up floor)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precomputed Visibility"})," (",(0,r.jsx)(n.code,{children:"pvstype"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disabled"}),"\n",(0,r.jsx)(n.li,{children:"Test map (open space, no skybox)"}),"\n",(0,r.jsx)(n.li,{children:"Full visibility solve"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Export Steam Audio Geometry"})," (",(0,r.jsx)(n.code,{children:"steamaudio_export"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">"]}),"\n"]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var i=s(96540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}},60543:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>x,default:()=>m,frontMatter:()=>h,metadata:()=>i,toc:()=>j});const i=JSON.parse('{"id":"Entities/worldspawn","title":"worldspawn","description":"\x3c!---","source":"@site/docs/Entities/worldspawn.mdx","sourceDirName":"Entities","slug":"/Entities/worldspawn","permalink":"/Entities/worldspawn","draft":false,"unlisted":false,"editUrl":"/HowToEdit/entity-page-info","tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true,"custom_edit_url":"/HowToEdit/entity-page-info"},"sidebar":"tutorialSidebar","previous":{"title":"world_bounds","permalink":"/Entities/world_bounds"},"next":{"title":"xen_flora_animatedmover","permalink":"/Entities/xen_flora_animatedmover"}}');var r=s(74848),l=s(28453),t=s(18014),o=s(21082),a=s(92539),d=s(79386),c=s(27592);const h={hide_table_of_contents:!0,custom_edit_url:"/HowToEdit/entity-page-info"},x="worldspawn",u={},j=[];function p(e){const n={h1:"h1",header:"header",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"worldspawn",children:"worldspawn"})}),"\n","\n",(0,r.jsx)(t.A,{cs2:(0,r.jsx)(o.default,{}),hla:(0,r.jsx)(a.default,{}),dota2:(0,r.jsx)(d.default,{}),steamvr:(0,r.jsx)(c.default,{})})]})}function m(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},79386:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"type":"mdx","permalink":"/Entities/worldspawn-dota2","source":"@site/src/pages/Entities/worldspawn-dota2.mdx","description":"\x3c!---","frontMatter":{"hide_table_of_contents":true},"unlisted":false}');var r=s(74848),l=s(28453);const t={hide_table_of_contents:!0},o=void 0,a={},d=[];function c(e){const n={br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Mesh Entity"}),"\n",(0,r.jsx)(n.p,{children:"This is the world entity. Each map can only contain one, and it's automatically created for you."}),"\n",(0,r.jsxs)(s,{open:!0,children:[(0,r.jsx)("summary",{children:(0,r.jsx)("h2",{children:"Keyvalues"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Name"})," (",(0,r.jsx)(n.code,{children:"targetname"}),") <",(0,r.jsx)(n.code,{children:"TargetSource"}),">",(0,r.jsx)(n.br,{}),"\n","The name that other entities refer to this entity by."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"SkyBox Texture Name"})," (",(0,r.jsx)(n.code,{children:"skyname"}),") <",(0,r.jsx)(n.code,{children:"String"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In"})," (",(0,r.jsx)(n.code,{children:"startdark"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In Color (R G B)"})," (",(0,r.jsx)(n.code,{children:"startcolor"}),") <",(0,r.jsx)(n.code,{children:"Color255"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precomputed Visibility"})," (",(0,r.jsx)(n.code,{children:"pvstype"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disabled"}),"\n",(0,r.jsx)(n.li,{children:"Test map (open space, no skybox)"}),"\n",(0,r.jsx)(n.li,{children:"Full visibility solve"}),"\n",(0,r.jsx)(n.li,{children:"Partitioned solve (large map volume)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"New Level Unit"})," (",(0,r.jsx)(n.code,{children:"newunit"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No, keep current"}),"\n",(0,r.jsx)(n.li,{children:"Yes, clear previous levels"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Start Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"maxpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"minpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precomputed Visibility"})," (",(0,r.jsx)(n.code,{children:"pvstype"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disabled"}),"\n",(0,r.jsx)(n.li,{children:"Test map (open space, no skybox)"}),"\n",(0,r.jsx)(n.li,{children:"Full visibility solve"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Optimized Heightfield Name"})," (",(0,r.jsx)(n.code,{children:"OptimizedHeightFieldName"}),") <",(0,r.jsx)(n.code,{children:"String"}),">",(0,r.jsx)(n.br,{}),"\n","Optional name of an optimized heightfield to use for ground traces. An example is maps/someheightfield.bin."]}),"\n"]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},92539:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"type":"mdx","permalink":"/Entities/worldspawn-hla","source":"@site/src/pages/Entities/worldspawn-hla.mdx","description":"\x3c!---","frontMatter":{"hide_table_of_contents":true},"unlisted":false}');var r=s(74848),l=s(28453);const t={hide_table_of_contents:!0},o=void 0,a={},d=[];function c(e){const n={br:"br",code:"code",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Mesh Entity"}),"\n",(0,r.jsx)(n.p,{children:"This is the world entity. Each map can only contain one, and it's automatically created for you."}),"\n",(0,r.jsxs)(s,{open:!0,children:[(0,r.jsx)("summary",{children:(0,r.jsx)("h2",{children:"Keyvalues"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Name"})," (",(0,r.jsx)(n.code,{children:"targetname"}),") <",(0,r.jsx)(n.code,{children:"TargetSource"}),">",(0,r.jsx)(n.br,{}),"\n","The name that other entities refer to this entity by."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"SkyBox Texture Name"})," (",(0,r.jsx)(n.code,{children:"skyname"}),") <",(0,r.jsx)(n.code,{children:"String"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In"})," (",(0,r.jsx)(n.code,{children:"startdark"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Level Fade In Color (R G B)"})," (",(0,r.jsx)(n.code,{children:"startcolor"}),") <",(0,r.jsx)(n.code,{children:"Color255"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Precomputed Visibility"})," (",(0,r.jsx)(n.code,{children:"pvstype"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disabled"}),"\n",(0,r.jsx)(n.li,{children:"Test map (open space, no skybox)"}),"\n",(0,r.jsx)(n.li,{children:"Full visibility solve"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"New Level Unit"})," (",(0,r.jsx)(n.code,{children:"newunit"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">",(0,r.jsx)(n.br,{}),"\n","Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No, keep current"}),"\n",(0,r.jsx)(n.li,{children:"Yes, clear previous levels"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Start Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"maxpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End Fade Pixels"})," (",(0,r.jsx)(n.code,{children:"minpropscreenwidth"}),") <",(0,r.jsx)(n.code,{children:"Float"}),">",(0,r.jsx)(n.br,{}),"\n","Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"VR Chaperone"})," (",(0,r.jsx)(n.code,{children:"vrchaperone"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Chaperone"}),"\n",(0,r.jsx)(n.li,{children:"Chaperone + Safe Zone"}),"\n",(0,r.jsx)(n.li,{children:"No Chaperone"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"VR Movement"})," (",(0,r.jsx)(n.code,{children:"vrmovement"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"None"}),"\n",(0,r.jsx)(n.li,{children:"Teleport"}),"\n",(0,r.jsx)(n.li,{children:"Teleport (w/non-up floor)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baked Light Minimum Index"})," (",(0,r.jsx)(n.code,{children:"baked_light_index_min"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","Baked lights in this map will not have a value smaller than this number. Use to avoid conflicts in dynamically loaded prefabs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Baked Light Maximum Index"})," (",(0,r.jsx)(n.code,{children:"baked_light_index_max"}),") <",(0,r.jsx)(n.code,{children:"Integer"}),">",(0,r.jsx)(n.br,{}),"\n","Baked lights in this map will not have a value equal to or larger than this number. Use to avoid conflicts in dynamically loaded prefabs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Maximum Lightmap Resolution"})," (",(0,r.jsx)(n.code,{children:"max_lightmap_resolution"}),") <",(0,r.jsx)(n.code,{children:"Choices"}),">"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No Maximum"}),"\n",(0,r.jsx)(n.li,{children:"512"}),"\n",(0,r.jsx)(n.li,{children:"1024"}),"\n",(0,r.jsx)(n.li,{children:"2048"}),"\n",(0,r.jsx)(n.li,{children:"4096"}),"\n",(0,r.jsx)(n.li,{children:"8192"}),"\n",(0,r.jsx)(n.li,{children:"16384"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lightmap Queries"})," (",(0,r.jsx)(n.code,{children:"lightmap_queries"}),") <",(0,r.jsx)(n.code,{children:"Boolean"}),">",(0,r.jsx)(n.br,{}),"\n","Generates data which can be used to lookup lightmap UVs at a given position, useful for high-fidelity illumination of bullet decals on lightmapped geometry."]}),"\n"]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);