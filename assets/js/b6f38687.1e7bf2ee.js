"use strict";(self.webpackChunksource_2_wiki=self.webpackChunksource_2_wiki||[]).push([[27079],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var r=t(96540);const a={},s=r.createContext(a);function c(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),r.createElement(s.Provider,{value:n},e.children)}},31593:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Scripting/Counter-Strike 2/cs_script/examples/trace","title":"Traces","description":"A script showcasing tracing lines, spheres, boxes and bullets.","source":"@site/docs/Scripting/Counter-Strike 2/cs_script/examples/4-trace.mdx","sourceDirName":"Scripting/Counter-Strike 2/cs_script/examples","slug":"/Scripting/Counter-Strike 2/cs_script/examples/trace","permalink":"/Scripting/Counter-Strike 2/cs_script/examples/trace","draft":false,"unlisted":false,"editUrl":"https://github.com/Source2Wiki/Source2Wiki/blob/master/docs/Scripting/Counter-Strike 2/cs_script/examples/4-trace.mdx?plain=1","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Grenade Training","permalink":"/Scripting/Counter-Strike 2/cs_script/examples/grenadetraining"},"next":{"title":"Chess","permalink":"/Scripting/Counter-Strike 2/cs_script/examples/chess"}}');var a=t(74848),s=t(28453);const c={},o="Traces",i={},l=[];function p(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"traces",children:"Traces"})}),"\n",(0,a.jsx)(n.p,{children:"A script showcasing tracing lines, spheres, boxes and bullets."}),"\n",(0,a.jsxs)(n.p,{children:["found at ",(0,a.jsx)(n.code,{children:"Counter-Strike Global Offensive\\content\\csgo\\maps\\editor\\zoo\\scripts\\trace.js"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { CSHitGroup, CSPlayerPawn, Instance } from "cs_script/point_script";\n\nconst traceFrequency = 0;\nconst drawDuration = 0;\n\n/** @type {"line" | "sphere" | "box" | "bullet" | null} */\nlet traceType = null;\n/** @type {CSPlayerPawn | undefined} */\nlet tracePawn = undefined;\n\nInstance.OnScriptReload({\n    before: () => {\n        return { traceType, tracePawn };\n    },\n    after: (memory) => {\n        if (memory) {\n            traceType = memory.traceType;\n            tracePawn = memory.tracePawn;\n        }\n    },\n});\n\nInstance.OnPlayerChat(({ player, text }) => {\n    tracePawn = player?.GetPlayerPawn();\n    if (text === "!traceline") {\n        traceType = "line";\n    } else if (text === "!tracesphere") {\n        traceType = "sphere";\n    } else if (text === "!tracebox") {\n        traceType = "box";\n    } else if (text === "!tracebullet") {\n        traceType = "bullet";\n    } else {\n        traceType = null;\n    }\n});\n\nInstance.SetThink(() => {\n    Instance.SetNextThink(Instance.GetGameTime() + traceFrequency);\n    if (!tracePawn || !tracePawn.IsValid()) return;\n\n    const start = tracePawn.GetEyePosition();\n    const forward = getForward(tracePawn.GetEyeAngles());\n    const end = vectorAdd(start, vectorScale(forward, 4000));\n\n    if (traceType === "line") {\n        const result = Instance.TraceLine({ start, end, ignoreEntity: tracePawn });\n\n        if (result.didHit) {\n            Instance.DebugSphere({ center: result.end, radius: 1, duration: drawDuration, color: { r: 255, g: 0, b: 0 } });\n            const normalEnd = vectorAdd(result.end, vectorScale(result.normal, 10));\n            Instance.DebugLine({ start: result.end, end: normalEnd, duration: drawDuration, color: { r: 255, g: 255, b: 0 } });\n        }\n    } else if (traceType === "sphere") {\n        const result = Instance.TraceSphere({ start, end, radius: 10, ignoreEntity: tracePawn, ignorePlayers: true });\n\n        Instance.DebugSphere({ center: result.end, radius: 5, duration: drawDuration, color: { r: 255, g: 0, b: 0 } });\n        if (result.didHit) {\n            const normalStart = vectorAdd(result.end, vectorScale(result.normal, 5));\n            const normalEnd = vectorAdd(normalStart, vectorScale(result.normal, 10));\n            Instance.DebugLine({ start: normalStart, end: normalEnd, duration: drawDuration, color: { r: 255, g: 255, b: 0 } });\n        }\n    } else if (traceType === "box") {\n        const mins = { x: -10, y: -10, z: -10 };\n        const maxs = { x: 10, y: 10, z: 10 };\n\n        const result = Instance.TraceBox({ start, end, mins, maxs, ignoreEntity: tracePawn });\n\n        Instance.DebugBox({ mins: vectorAdd(result.end, mins), maxs: vectorAdd(result.end, maxs), duration: drawDuration, color: { r: 255, g: 0, b: 0 } });\n        if (result.didHit) {\n            const normalEnd = vectorAdd(result.end, vectorScale(result.normal, 10));\n            Instance.DebugLine({ start: result.end, end: normalEnd, duration: drawDuration, color: { r: 255, g: 255, b: 0 } });\n        }\n    } else if (traceType === "bullet") {\n        let weaponData = tracePawn.GetActiveWeapon()?.GetData();\n        if (!weaponData) return;\n\n        const end = vectorAdd(start, vectorScale(forward, weaponData.GetRange()));\n\n        const mins = { x: -1, y: -1, z: -1 };\n        const maxs = { x: 1, y: 1, z: 1 };\n\n        const results = Instance.TraceBullet({\n            start,\n            end,\n            shooter: tracePawn,\n            damage: weaponData.GetDamage(),\n            rangeModifier: weaponData.GetRangeModifier(),\n            penetration: weaponData.GetPenetration(),\n        });\n        for (const result of results) {\n            let color = { r: 255, g: 0, b: 0 };\n            if (result.hitEntity.IsWorld()) {\n                color = { r: 0, g: 0, b: 255 };\n            } else if (result.damage < 1) {\n                color = { r: 0, g: 255, b: 0 };\n            } else if (result.damage < 100) {\n                color.g = lerp(255, 0, result.damage / 100);\n            } else if (result.damage > 100) {\n                color.b = lerp(0, 255, (result.damage - 100) / 100);\n            }\n            if (result.hitGroup == CSHitGroup.HEAD) {\n                Instance.DebugSphere({ center: result.position, radius: 1, duration: drawDuration, color });\n            } else {\n                Instance.DebugBox({ mins: vectorAdd(result.position, mins), maxs: vectorAdd(result.position, maxs), duration: drawDuration, color });\n            }\n        }\n    }\n});\nInstance.SetNextThink(Instance.GetGameTime());\n\n/**\n * @param {import("cs_script/point_script").Vector} vec1\n * @param {import("cs_script/point_script").Vector} vec2\n * @returns {import("cs_script/point_script").Vector}\n */\nfunction vectorAdd(vec1, vec2) {\n    return { x: vec1.x + vec2.x, y: vec1.y + vec2.y, z: vec1.z + vec2.z };\n}\n\n/**\n * @param {import("cs_script/point_script").Vector} vec\n * @param {number} scale\n * @returns {import("cs_script/point_script").Vector}\n */\nfunction vectorScale(vec, scale) {\n    return { x: vec.x * scale, y: vec.y * scale, z: vec.z * scale };\n}\n\n/**\n * @param {import("cs_script/point_script").QAngle} angles\n * @returns {import("cs_script/point_script").Vector}\n */\nfunction getForward(angles) {\n    const pitchRadians = (angles.pitch * Math.PI) / 180;\n    const yawRadians = (angles.yaw * Math.PI) / 180;\n    const hScale = Math.cos(pitchRadians);\n    return {\n        x: Math.cos(yawRadians) * hScale,\n        y: Math.sin(yawRadians) * hScale,\n        z: -Math.sin(pitchRadians),\n    };\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @param {number} t\n */\nfunction lerp(a, b, t) {\n    return a + (b - a) * t;\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);